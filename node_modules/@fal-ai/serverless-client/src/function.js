"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.queue = exports.subscribe = exports.run = exports.send = exports.buildUrl = void 0;
const request_1 = require("./request");
const storage_1 = require("./storage");
const utils_1 = require("./utils");
/**
 * Builds the final url to run the function based on its `id` or alias and
 * a the options from `RunOptions<Input>`.
 *
 * @private
 * @param id the function id or alias
 * @param options the run options
 * @returns the final url to run the function
 */
function buildUrl(id, options = {}) {
    var _a, _b;
    const method = ((_a = options.method) !== null && _a !== void 0 ? _a : 'post').toLowerCase();
    const path = ((_b = options.path) !== null && _b !== void 0 ? _b : '').replace(/^\//, '').replace(/\/{2,}/, '/');
    const input = options.input;
    const params = 
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    method === 'get' && input ? new URLSearchParams(input) : undefined;
    const queryParams = params ? `?${params.toString()}` : '';
    const parts = id.split('/');
    // if a fal url is passed, just use it
    if ((0, utils_1.isValidUrl)(id)) {
        const url = id.endsWith('/') ? id : `${id}/`;
        return `${url}${path}${queryParams}`;
    }
    // TODO remove this after some time, fal.run should be preferred
    if (parts.length === 2 && (0, utils_1.isUUIDv4)(parts[1])) {
        const host = 'gateway.shark.fal.ai';
        return `https://${host}/trigger/${id}/${path}${queryParams}`;
    }
    const appId = (0, utils_1.ensureAppIdFormat)(id);
    const subdomain = options.subdomain ? `${options.subdomain}.` : '';
    const url = `https://${subdomain}fal.run/${appId}/${path}`;
    return `${url.replace(/\/$/, '')}${queryParams}`;
}
exports.buildUrl = buildUrl;
function send(id, options = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const input = options.input && options.autoUpload !== false
            ? yield storage_1.storageImpl.transformInput(options.input)
            : options.input;
        return (0, request_1.dispatchRequest)((_a = options.method) !== null && _a !== void 0 ? _a : 'post', buildUrl(id, options), input);
    });
}
exports.send = send;
/**
 * Runs a fal serverless function identified by its `id`.
 *
 * @param id the registered function revision id or alias.
 * @returns the remote function output
 */
function run(id, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return send(id, options);
    });
}
exports.run = run;
/**
 * Subscribes to updates for a specific request in the queue.
 *
 * @param id - The ID or URL of the function web endpoint.
 * @param options - Options to configure how the request is run and how updates are received.
 * @returns A promise that resolves to the result of the request once it's completed.
 */
function subscribe(id, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { request_id: requestId } = yield exports.queue.submit(id, options);
        if (options.onEnqueue) {
            options.onEnqueue(requestId);
        }
        return new Promise((resolve, reject) => {
            var _a;
            let timeoutId;
            const pollInterval = (_a = options.pollInterval) !== null && _a !== void 0 ? _a : 1000;
            const poll = () => __awaiter(this, void 0, void 0, function* () {
                var _b;
                try {
                    const requestStatus = yield exports.queue.status(id, {
                        requestId,
                        logs: (_b = options.logs) !== null && _b !== void 0 ? _b : false,
                    });
                    if (options.onQueueUpdate) {
                        options.onQueueUpdate(requestStatus);
                    }
                    if (requestStatus.status === 'COMPLETED') {
                        clearTimeout(timeoutId);
                        try {
                            const result = yield exports.queue.result(id, { requestId });
                            resolve(result);
                        }
                        catch (error) {
                            reject(error);
                        }
                        return;
                    }
                    timeoutId = setTimeout(poll, pollInterval);
                }
                catch (error) {
                    clearTimeout(timeoutId);
                    reject(error);
                }
            });
            poll().catch(reject);
        });
    });
}
exports.subscribe = subscribe;
/**
 * The fal run queue module. It allows to submit a function to the queue and get its result
 * on a separate call. This is useful for long running functions that can be executed
 * asynchronously and not .
 */
exports.queue = {
    submit(id, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { webhookUrl, path = '' } = options, runOptions = __rest(options, ["webhookUrl", "path"]);
            const query = webhookUrl
                ? '?' + new URLSearchParams({ fal_webhook: webhookUrl }).toString()
                : '';
            return send(id, Object.assign(Object.assign({}, runOptions), { subdomain: 'queue', method: 'post', path: path + query }));
        });
    },
    status(id, { requestId, logs = false }) {
        return __awaiter(this, void 0, void 0, function* () {
            const appId = (0, utils_1.parseAppId)(id);
            const prefix = appId.namespace ? `${appId.namespace}/` : '';
            return send(`${prefix}${appId.owner}/${appId.alias}`, {
                subdomain: 'queue',
                method: 'get',
                path: `/requests/${requestId}/status`,
                input: {
                    logs: logs ? '1' : '0',
                },
            });
        });
    },
    result(id, { requestId }) {
        return __awaiter(this, void 0, void 0, function* () {
            const appId = (0, utils_1.parseAppId)(id);
            const prefix = appId.namespace ? `${appId.namespace}/` : '';
            return send(`${prefix}${appId.owner}/${appId.alias}`, {
                subdomain: 'queue',
                method: 'get',
                path: `/requests/${requestId}`,
            });
        });
    },
    subscribe,
};
//# sourceMappingURL=function.js.map