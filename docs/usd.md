了解しました。.usdaファイルの文法（構文ルールやキーワードなど）に特化して、詳細に調査を進めます。

具体的には、ファイルの構文、セクションの構成、主要キーワードとその使い方、データ型や属性の表記法などについて焦点を当てて整理します。しばらくお待ちください。


# USDAファイル構文仕様（Universal Scene Description ASCII）

## ファイル構造とヘッダ

USDAファイルはUTF-8のテキスト形式で、まずファイルの冒頭に**マジックコード**として`#usda 1.0`を記述します。続いて、ファイル全体に適用される**レイヤーのメタデータ**ブロックを丸括弧 `(...)` 内に指定できます（省略も可能）。例えば、デフォルトプリムや単位系、アップ軸、サブレイヤーの指定などをここで行います。

```usda
#usda 1.0
(
    defaultPrim = "Scene"                     # デフォルトで開くプリム名
    upAxis = "Y"                              # 上方向の軸（"Y"や"Z"）
    metersPerUnit = 1.0                       # スケール（1単位あたりのメートル値）
    subLayers = [                             # サブレイヤーのリスト（弱い順に下から順に適用）
        @env.usd@,
        @char.usd@,
        @props.usd@
    ]
)
```

上記のように、ヘッダ内のメタデータは `(キー = 値)` という書式で列挙します。`subLayers`には他のUSDファイルをリスト形式で指定でき、これらは**レイヤースタック**として順次合成されます。`defaultPrim`はファイルをロードした際にルートとして使用されるプリム名の指定です。また`upAxis`や`metersPerUnit`のようにシーン全体に及ぶ設定も記述可能です。ヘッダの丸括弧は省略可能で、内容がなければ`#usda 1.0`の直後に空の`()`を置くこともあります。

**コメント**はファイル中でハッシュ記号（`#`）から行末までがコメント扱いとなります。`#usda`の行以外で先頭に`#`を付ければコメントを記述できます（UTF-8テキストとして日本語コメントも可能）。例えば:

```usda
    # これはコメントです。USDAファイル中で説明を書くことができます。
    # 複数行のコメントも、各行に#を付けます。
```

空白や改行は基本的に自由で、インデントも視認性のために用いられます（構文上はブロックの波括弧 `{}` でネストを表現するため、インデントは必須ではありません）。文字列リテラル中ではバックスラッシュによる**エスケープ**が可能で、例えば `\"` でダブルクオート自体を表記できます。また改行やタブも `\n` や `\t` のようにエスケープできます。

## プリム定義ブロックと階層構造

USDのシーン構造は\*\*プリム（Prim）\*\*と呼ばれるノードの階層で表現され、USDAではプリムごとにブロック構文で記述します。基本形は以下の通りです。

```usda
def <PrimType> "<PrimName>" ( <メタデータ...> ) {
    <プロパティや子プリム定義...>
}
```

* **`def`** … 新規にプリムを定義するキーワードです。後述の`class`や`over`と対比して、実体のあるプリム定義を行います。
* **`PrimType`** … オプションで、プリムの型を指定します（省略すれば型指定なしの汎用プリム）。例えば`Xform`や`Mesh`、カスタムSchemaの型名などが指定できます。
* **`PrimName`** … ダブルクオートで囲んだプリム名です。シーン階層中でこの名前がノード名になります。
* **メタデータ丸括弧 `(...)`** … プリムに紐づくメタデータや**コンポジションアーク**（後述する参照や継承など）を指定できます。無ければ空の`()`または省略可能です。
* **ブロック `{ ... }`** … 波括弧で囲まれた中に、このプリムの**プロパティ（属性やリレーション）**や**子プリム**の定義を記述します。ブロックを閉じる`}`までがそのプリムの内容を表します。

\*\*ネスト（階層構造）\*\*はブロックの入れ子で表現します。次の例はプリムの階層をUSDAで書いたものです。

```usda
def Xform "World" {
    def Xform "Sets" {
        def Xform "Bookshelf" {
            def Xform "Book_1" {
                string name = "Toy Story"
            }
        }
        def Xform "Desk" {
        }
    }
}
```

この例では`World`直下に`Sets`プリムがあり、その中に`Bookshelf`と`Desk`という子プリムが定義されています。さらに`Bookshelf`の中には`Book_1`プリムがあり、属性`name`が設定されています。各ブロックの閉じ括弧`}`によって親プリムの範囲が閉じられ、階層構造が明確に示されています。実際のUSDシーンにおいてプリムは「`/World/Sets/Bookshelf/Book_1`」のようなパス階層になります。

## プリム定義の主なキーワード: `def`・`class`・`over`

\*\*`def`（Define）\*\*は前述した通り、新規プリムを定義するための基本キーワードです。これに対し、USDには他にもプリム定義のバリエーションがあります。

* **`class`** … クラスプリムを定義します。これは実際のシーンに直接は現れない**抽象プリム**で、他のプリムが**継承**するためのテンプレートとして機能します。`class`で定義されたプリムは階層上のオブジェクトですが、`def`との違いは**継承専用**である点です。例えば:

  ```usda
  class "CharacterBase" {
      float health = 100
      string species = "Human"
  }
  def "Hero" (
      inherits = </CharacterBase>
  ) {
      string name = "Arthur"
  }
  ```

  上記では`CharacterBase`を`class`として定義し、通常のプリム`Hero`のメタデータで`inherits = </CharacterBase>`と指定することで、`Hero`プリムは`CharacterBase`の属性（`health`や`species`）を継承します。`class`プリム自体はステージ上に実体化せず、他プリムへのプロパティ供与源となります。

* **`over`** … 既存のプリムに対する**オーバーライド**（強い意見の付与）を行うためのキーワードです。`over`は新たな値や設定で既存プリムを部分的に上書きする際に使われます。`over`ブロックは原則として型指定を持たず（型指定はできません）、プリム名だけを指定します。例えば、別のレイヤーで`/World/Sets/Bookshelf/Book_1`の`name`を変更するには、そのレイヤーに:

  ```usda
  over "Book_1" {
      string name = "Wall-E"
  }
  ```

  のように記述します（この`over`プリムは上位レイヤーで既存の`Book_1`にマージされ、`name`属性の値を差し替えます）。`over`は**弱いレイヤーに定義されたプリムを強いレイヤーから修正する**用途であり、単独のファイル内で新規定義として使うことは通常ありません。`over`指定されたプリムは、そのファイル単体では実体を持たず不完全ですが、他ファイルからの参照やサブレイヤーによって存在が補完されます。

* **`inherits`**（継承）… これはキーワードではなく**プリムのメタデータ**項目ですが、上記`class`と対で用いられます。プリム定義の丸括弧内で`inherits = </Path/To/ClassPrim>`と書くことで、そのプリムは指定したパスのクラスプリムを継承します。継承すると、クラスプリムで`def`inedされているプロパティが継承先プリムに無ければ適用されます（あくまで**初期値**や**存在**を受け継ぎ、継承先で個別に上書きも可能）。`inherits`には複数のパスを**リスト**で指定することもできます（この場合カンマ区切りで`[</Class1>, </Class2>, ...]`と記述）。

以上のように、`def`/`class`/`over`は\*\*プリムの仕様（Specifier）\*\*と呼ばれ、USD内部ではプリムに与えられた役割を示しています。「`def = 定義`」「`class = 継承用定義`」「`over = 上書き`」と覚えると良いでしょう。

## 属性（Attribute）の記述方法とデータ型

プリムのブロック内では、\*\*属性（Attribute）\*\*を記述してプリムに様々な値を持たせることができます。属性の書式は:

```usda
<修飾子> <データ型> <属性名> = <値>
```

基本的な例を示します:

```usda
def Cube "box" {
    double size = 1.0
    rel material:binding = </Materials/Mat1>
}
```

上記では、`box`という名前の`Cube`型プリムの中に、`double`（倍精度浮動小数）型の属性`size`を`1.0`で定義しています。また、`material:binding`というリレーションシップも設定しています（リレーションシップについては後述）。

### 属性のデータ型とリテラル表記

USDで使用可能なデータ型は豊富に用意されており、USDAでは**トークン**（型名）で指定します。主なスカラー型は以下の通りです。

* `bool` (ブール値: 真偽値。`True`または`False`と記述)
* `int`, `uint` (32bit符号付き/無し整数)、`int64`, `uint64` (64bit整数)
* `half` (16bit浮動小数), `float` (32bit浮動小数), `double` (64bit浮動小数)
* `string` (文字列)、`token` (トークン: 高速比較用のインターンされた文字列)
* `asset` (アセットパス: 他ファイル参照用のパス文字列)
* `timecode` (TimeCode: 時間を示す特殊なdouble)
* （この他`uchar`や`opaque`など特殊型もあります）

ベクトルや行列など複合型も存在します。**ベクトル型**は要素数と基本型を組み合わせた型名で、例えば`float3`は3要素の浮動小数ベクトル、`double2`は2要素の倍精度ベクトルです。RGBAカラーやポイントなど用途別のエイリアス（例: `color3f`, `point3f` 等）も存在します。**行列型**は`matrix2d`, `matrix3d`, `matrix4d`があり、それぞれ2x2, 3x3, 4x4のdouble行列です。四元数型として`quatf`/`quatd`/`quath`も用意されています。

各データ型に対応する**リテラル表記**は以下のようになります。

* **ブール値**: `True` または `False` と先頭大文字で記述します。
* **数値**: 整数はそのまま (例: `42`)、浮動小数は小数点付きで (例: `3.14`、`2.0`)。指数表記(e.g. `1e-3`)も可能です。
* **文字列**: ダブルクオートで囲みます (例: `"Hello USD"`)。ダブルクオート自体を含める場合は `\"` とエスケープします。文字列内でバックスラッシュも `\\` のようにエスケープします。
* **トークン**: トークン値も文字列同様にクオートで記述します（例: `token purpose = "guide"` とすると値が`guide`というトークンになる）。トークンは内部的にストリングより効率的に比較されますが、記述上はstringと同様です。
* **ベクター/ポイント**: 複数要素は丸括弧でタプルのように括ります。例: `float3 somePoint = (1.0, 2.0, 3.5)`、`double2 uv = (0.1, 0.2)`。ベクトル**配列**の場合は各要素タプルをさらにリストで括ります（後述の配列リテラル参照）。
* **行列**: 行列は括弧内に行をさらに括弧で列挙します。例えば4x4行列の場合: `matrix4d xform = ( (1,0,0,0), (0,1,0,0), (0,0,1,0), (0,0,0,1) )` といった形式です。
* **アセットパス**: アセット（他ファイル）パスは`@`で囲んで記述します (例: `asset myFile = @path/to/file.usd@`)。

### 配列型の表記

すべてのデータ型は\*\*配列（array）\*\*にすることが可能です。USDAでは型名の後ろに`[]`を付けて属性を宣言し、値は角括弧 `[...]` で括ってリスト形式で記述します。配列要素が複合型の場合、それぞれを丸括弧で囲みます。例:

```usda
int[] indices = [0, 1, 2, 3, 4]                      # 整数の配列
float3[] positions = [ (0,0,0), (1,0,0), (1,1,0) ]   # 3要素ベクトルの配列
string[] names = [ "Alice", "Bob", "Charlie" ]       # 文字列の配列
```

要素が0個の場合は空の`[]`とします。1個だけの場合でも`[...]`で囲むのが一般的ですが、USDAの構文上は単一値を角括弧なしで書いても単一要素リストとみなされる場合があります（例えば`variantSets = "set1"`は`["set1"]`と同義）。可読性のため明示的に`[...]`を使う方が無難です。

### 属性の修飾子: `custom`・`uniform`・他

属性定義の先頭にはオプションの修飾子を付けることができます。

* **`custom`**: その型の既定Schemaに存在しない独自属性であることを示します。例えば、あるプリム型に本来定義されないユーザ拡張の属性を追加する際に`custom`を付与します。プリムの型がわかっており、Schema既定の属性であれば省略可能です。USDはschemaにない属性も保持できますが、`custom`を付けることで将来Schemaに同名プロパティが追加された場合との衝突を避ける意図があります。
* **`uniform`**: 変化しない属性（時間的に一定、すなわち`variability`が`Uniform`）であることを示します。アニメーションしない定数値や、Primvarにおける**定数補間**の指定に使われます。デフォルトでは属性は時間的に`Varying`（可変）と見なされますが、`uniform`キーワードを付けると強制的に時間的に固定の値として扱われます。例えば`uniform token[] xformOpOrder = ["xformOp:translate"]`のように使います。
* **`rel`**: これは修飾子ではなく**リレーションシップ**の定義を示すキーワードですが、属性定義と並んでプロパティブロック内に記述されます。次節で詳述します。

この他、Schemaや拡張で特殊な目的の修飾子が付く場合もありますが、基本的なUSDA記述では上記が押さえてあれば十分です。

### タイムサンプル（時間的な値変化）

USDは属性の時間変化（アニメーション）を**TimeSamples**で記録できます。USDAでは属性名に続けて`.timeSamples`を付け、波括弧 `{}` 内に「時間:値」のペアを列挙することで指定します。

```usda
double xformOp:translate:translateX.timeSamples = {
    0: 0.0,
    1: 10.0,
    2: 20.0
}
```

上記は`xformOp:translate:translateX`属性が、タイムコード0で0.0、1で10.0、2で20.0という値を取ることを表します。時間は基本的に\*\*タイムコード（秒ではなく任意単位）\*\*で、`timeCodesPerSecond`等で1秒あたりのタイムコード数が決まります。なお、`.timeSamples`を使う属性には通常`default`（デフォルト値）は併記しません（併記するとデフォルトとサンプルで二重定義になるため）。時間サンプルを解除（値をクリア）したい場合、強いレイヤーで`None`を指定することも可能です。

### 属性の接続（Connections）

属性の値として、別のプリムの属性に**接続**することもできます。これにより、ある属性の値を他の場所にある属性の値で駆動できます。USDAでは、属性名に続けて`.connect`を付け、右辺に**接続先のパス**を山括弧 `<...>` で記述します。

```usda
float3 outputs:result.connect = </Sphere1/outputs:someValue>
```

上記は現在のプリムの`outputs:result`という属性が、シーン内の`/Sphere1`プリムの`outputs:someValue`と接続されていることを意味します。接続はあくまで参照であり、実際の値は接続先から取得されます。配列型の属性に複数接続する場合は、右辺を配列で`[<ターゲット1>, <ターゲット2>, ...]`のように記述します。また接続にもリスト編集（後述）が適用可能で、`prepend`や`append`を用いて接続ターゲットの追加順序を操作できます。

なお、リレーションシップ（後述）と属性接続はいずれも`< ... >`でパスを指定しますが、**属性接続は「属性同士」の紐付け**であり、リレーションシップは「プリム間（またはプリム-プロパティ間）の任意の関連」を表す点で異なります。

## リレーションシップ（Relationship）の文法

**リレーションシップ（rel）**は、USDにおける**参照的なリンク**を表すプロパティです。リレーションシップは型を持たず、シーン内の他の要素（主に他プリム）への**パス**の集合を保持します。USDAでは属性と区別するため、`rel <名前> = <ターゲットパス>`という書式で記述します。例えば:

```usda
rel material:binding = </Looks/PlasticMaterial>
```

これは現在のプリムの`material:binding`というリレーションシップが、シーン内の`/Looks/PlasticMaterial`というプリムをターゲットに持つことを意味します。この例ではターゲットは単一ですが、**リレーションシップは複数ターゲットを持つ**こともできます。その場合、値を角括弧で囲んだリストにします:

```usda
rel myTargets = [ </World/Cube1>, </World/Cube2> ]
```

リレーションシップ名にはコロン区切りで名前空間を含めることができます（例: `material:binding`）が、コロンは名前空間の区切りとして扱われ、実際のパスの一部ではありません。

リレーションシップの特徴:

* **型がない**: 単に関連付けを表すリンクなので型情報は持ちません。
* **ターゲット**: 常にUSDシーン内のパス（プリムやプロパティへのパス）を指します。上記のように`<...>`で囲んで指定し、絶対パスは`/`から、相対パスはピリオドや親参照（`..`）で記述できます。
* **値を持たない**: リレーションシップ自体は「関連」の名前であって値ではありません。従って`rel`には`default`や`timeSamples`の概念もありません（ターゲット集合自体が時間変化することはできません）。
* **リスト編集可能**: リレーションシップのターゲットリストは他のリスト型と同様、上位レイヤーで`prepend`, `append`, `delete`といった操作が可能です（後述）。

#### リレーションシップのメタデータ

リレーションシップにも追加のメタデータを付与できます。例えばMaterial Bindingにおける特殊なメタデータ`bindMaterialAs`などです。USDAではリレーションシップのターゲット指定の後に丸括弧でメタデータを記述します:

```usda
rel material:binding = </World/Looks/metal> (
    bindMaterialAs = "weakerThanDescendants"
)
```

上記では、リレーション`material:binding`のターゲットが`/World/Looks/metal`であり、さらに`bindMaterialAs`というメタデータに`"weakerThanDescendants"`というトークンを設定しています。このメタデータは「子孫プリムでのバインディングをオーバーライドしない弱い結合である」ことを示すUsdShade仕様の特例ですが、構文上はこのように付加情報を付けられることを示しています。一般にはリレーションシップのメタデータを直接記述することは稀で、多くの場合Material Bindingのような特殊用途に限られます。

## 他ファイルの参照: **References**と**Payload**

USDの強力な機能として、あるファイルから別のファイル内のプリムを**参照**（インクルード）することができます。これを実現するコンポジションアークが\*\*リファレンス（Reference）**と**ペイロード（Payload）\*\*です。USDAでの記述方法は両者とも似ています。

### References（参照）

**リファレンス**は、外部USDファイルのあるプリムを現在のプリムの下に挿入（合成）します。記述はプリム定義のメタデータ括弧内で、`references = @ファイルパス@<プリムパス>`と行います。例:

```usda
def "City" {
    def "Building_1" (
        references = @building.usd@</BuildingPrototype>
    ) {
        // Building_1固有の上書き属性
        string owner = "Alice"
    }
}
```

上記では、現在のファイル内の`/City/Building_1`プリムに対して、`building.usd`ファイル内の`/BuildingPrototype`プリムを参照として差し込みます。参照元ファイルの指定は`@...@`で囲み、後ろに`</...>`で**参照したいプリムのパス**を与えます（プリムパスを省略すると参照先ファイルの`defaultPrim`が使われます）。`references`はリストなので、複数の参照を持つこともできます。その場合は`[ @file1@<...>, @file2@<...> ]`のように角括弧で囲んで列挙します。参照を複数指定すると、それらが順に**積層**され複合結果を形成します（典型例としては基本形状→派生形状などの多重参照）。

リファレンスしたプリムは、あたかもその場に子プリムごと展開されたかのように振る舞います。ただし**名前空間**上は一体化する点に注意してください（例えば上の例では`Building_1`という名前だったものに`BuildingPrototype`がマージされますが、結果としてプリム名は`Building_1`のままです）。リファレンスする際、参照先のプリムがルート(`/`)そのものは指定できないという制約があります。そのため、他ファイルを参照用に作成する場合は内容を単一ルートプリムの下にまとめておくのが一般的です。

**List編集**: 参照リストも他のリスト型と同様に、上位レイヤーで`prepend references = ...`や`append references = ...`によって追加・順序操作が可能です。例えば、弱いレイヤーで`references = [A, B]`としていたプリムに、強いレイヤーで`prepend references = C`と書けば、最終的な参照順は`C, A, B`となります。リファレンス項目を取り除くには`delete references = A`のように書きます。

### Payload（ペイロード）

**ペイロード**も参照と似た仕組みですが、**遅延ロード可能な参照**として扱われます。記述は`payload = @ファイル@<プリムパス>`です（書式はreferencesと同様です）。Payloadに指定されたファイルは、ステージ生成時にデフォルトでは読み込まれず（**非ロード状態**）、明示的にロードする操作を行った時に初めて展開されます。こうすることで、大規模シーンの一部（詳細なジオメトリなど）を必要になるまで読み込まないようにできます。

構文上、payloadもreferencesと同じくプリムのメタデータ括弧内に書かれ、複数指定やlist編集が可能です。**ひとつのプリムに対し、referencesとpayloadは同時に使えません**（両者は似た役割のため）。優先すべきは「デフォルトでロードしたい内容はreferences、遅延させたいものはpayload」と使い分けます。

### インスタンシングと`instanceable`

USDでは、参照やペイロードしたプリムを**インスタンス化**（複数配置による効率化）することができます。具体的には、同じ参照結果を持つ複数のプリムを自動的に共有化して、シーングラフ上の重複を減らします。インスタンス化するには、参照元のプリム定義で`instanceable = true`というメタデータを指定します。例えば:

```usda
def "PropMaster" (
    payload = @prop_model.usdc@</Prop>  # 元となるプロトタイプ
    instanceable = true
) {}

def "Prop_1" (
    references = </PropMaster>
) {} 

def "Prop_2" (
    references = </PropMaster>
) {} 
```

上記で`PropMaster`プリムを`instanceable=true`にしておくと、`Prop_1`と`Prop_2`は共に`PropMaster`（経由で同じ外部ファイル`prop_model.usdc`内の`Prop`）を参照しており、同一の構造を持つため**インスタンス**とみなされます。USDはこれらインスタンスから共通の**プロトタイプPrim**を自動生成し、メモリ節約や処理負荷軽減を図ります。なお、インスタンス化されたプリムの**子孫は編集できなくなる**（プロトタイプ共有のため）という制約があります。その代わり、一括でプロトタイプを差し替えたり、上位Primに定義した`uniform`属性で見た目を変えるなどの手法が用意されています。

## Variants（バリアント）とVariantSetsの構文

**バリアント**は、単一プリムの下に**複数の状態のバリエーション**を持たせて切り替えるUSDの機能です。例えば「ドアが開いている状態/閉じている状態」を一つのプリムで持ち、シーンのコンテキストに応じて選択できます。

### VariantSetsの宣言とバリアントの定義

USDAでバリアントを使用するには、まずプリムに**バリアントセット**を宣言します。プリム定義のメタデータ括弧内で`variantSets = "セット名"`と記述します（複数ある場合は`["setA", "setB"]`のようにリスト）。さらに`variants = { string セット名 = "選択バリアント名" }`という書式で、そのプリム上で現在選択中のバリアントを指定します。例えば:

```usda
def Xform "Door" (
    variantSets = "state",
    variants = {
        string state = "Closed"
    }
) {
    variantSet "state" = {
        "Closed" {
            # Closedバリアント時の内容
            bool open = False
        }
        "Open" {
            # Openバリアント時の内容
            bool open = True
        }
    }
}
```

上記ではプリム`Door`に対し、`state`というバリアントセットを定義し、その選択値として`"Closed"`を指定しています。またプリムのブロック内で、`variantSet "state"`ブロックを記述し、その中に各バリアント名ごとのブロックを定義しています。`"Closed"`バリアントでは属性`open = False`を設定し、`"Open"`バリアントでは`open = True`を設定しています。このように、**variantSetブロック内**にバリアントごとのプリム階層や属性を定義できます。実際には`variantSet`ブロックの中は、そのプリムの**子スコープ**のように扱われ、各バリアントごとに異なる内容を記述できます。バリアント内には属性だけでなく子プリムを定義することも可能で、例えばあるバリアントでは詳細な内部構造を持ち、別のバリアントでは簡略なプロキシ形状だけ持つ、といったことができます。

### バリアントの選択と継承

`variants = { string state = "Closed" }`の部分で設定した選択肢は、ファイル読み込み時にそのプリムでデフォルト適用されます。ただし、上位のレイヤーから**強制的にバリアントを選択**することもできます。別のファイルで同じプリムパスに対して`variants = { string state = "Open" }`という`over`を置けば、シーン全体の組み立て時にそのバリアントが選択されます。USDではバリアント選択も一種の「オーバーライド可能な意見」であり、強い意見ほど最終選択に反映されます。

### 応用: 複雑なバリアント構造

バリアントは入れ子も可能です。すなわち、バリアント内にさらにvariantSetを持つ子プリムがあり、その中でまたバリアント分岐する、といった多段のケースも表現できます。構文上は単にプリム内にvariantSetブロックを作るだけなので特別な記法は不要です。

#### 特殊なコンポジションArcとの関係

バリアントと他のComposition Arc（サブレイヤーやリファレンス、継承など）を組み合わせる場合、その\*\*強度順（強い意見の適用優先度）\*\*に留意が必要です。一般に、Variantによる意見はSubLayerによる意見より弱く、Inheritsによる意見より強いという具合に順序があります（LIFERPSと呼ばれる優先順位）。これは文法というよりUSDのルールですが、複雑なシナリオでは構文上同じ記述でも結果が異なる場合があるため注意してください。

## リスト編集: `prepend`・`append`・`delete`・`reorder`

USDのもう一つの重要な構文要素として、**リスト編集操作**があります。これは、先述した参照リストやリレーションシップのターゲットリスト、あるいはトークンや文字列の配列メタデータなどに対し、上位レイヤーで要素の追加・削除・順序変更を指示するものです。文法的には対象となるリスト型プロパティの定義の先頭にキーワードを付与します。利用可能なキーワードと効果は次の通りです:

* **`prepend`** … 指定した要素をリストの先頭に追加します。
* **`append`** … 指定した要素をリストの末尾に追加します。
* **`add`** … `append`の古いエイリアス（現在は非推奨）。
* **`delete`** … 指定した要素がリストに存在すれば削除します。
* **`reorder`** … リスト内の要素の順序を再配置します。

例えば、弱いレイヤーで`custom rel primListLonger = [<a>, <b>, <c>]`と定義されているリレーションシップに対し、強いレイヤーで:

```usda
over "Example" {
    rel primList = <b>
    prepend rel primListLonger = <d>
}
```

と書くと、`primList`というリレーションは<strong>上書き</strong>されターゲットが`<b>`だけになりますが、`primListLonger`には`<d>`が先頭に追加され、元の`[<a>,<b>,<c>]`に対して`<d>`がプリペンドされた結果になります（最終的に`[<d>,<a>,<b>,<c>]`）。このように、リストを直接指定すると**置換**になり、`prepend`/`append`を付けると**追加**になります。また`delete`を使えば特定要素を除去可能です。同様の操作はリファレンスやペイロード、インheritsリスト、variantSetsリストなど様々なリスト型に適用できます。

`reorder`は特定のリストに対して要素の新しい順序を提示する特殊操作で、例えば`reorder variantSets = ["high","low"]`のように使うと、既存variantSetsリスト内の該当要素をその順に並べ替えます。`reorder`は他の要素は動かさず指定要素だけ順番を変える動作です。

以上、USDA（.usda）ファイルの構文要素を網羅的に説明しました。Pixar公式ドキュメントの仕様および実例に基づき記述しています。USDA記述は強力ですが柔軟性が高い分複雑でもあります。本リファレンスを参考に、ヘッダメタデータからプリム定義、属性・リレーション、コンポジションアーク、バリアントまで正確に記述することで、意図したUSDシーンを構築できるでしょう。

**参考資料**: Pixar/OpenUSD公式ドキュメント他、USDサンプルファイル実例など。
